<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drymaxxing - Global Rain Visualization</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            /* Gradient Background: Stratosphere -> Horizon -> Ground */
            background: linear-gradient(to bottom, #020111 0%, #191621 40%, #2c3e50 50%, #1a1a1a 60%, #000000 100%);
            font-family: 'Inter', sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            pointer-events: none;
            background: rgba(10, 10, 20, 0.7);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 10;
            width: 200px;
        }

        h1 {
            margin: 0 0 15px 0;
            font-size: 14px;
            font-weight: 600;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 10px;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-label {
            font-size: 11px;
            color: #8899aa;
            display: block;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 15px;
            font-weight: 600;
            font-feature-settings: "tnum";
            font-variant-numeric: tabular-nums;
        }

        canvas {
            border-radius: 4px;
            margin-top: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .controls-hint {
            margin-top: 20px;
            font-size: 10px;
            color: #556677;
            line-height: 1.5;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
        }
    </style>
    <!-- Three.js CDN -->
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
          }
        }
    </script>
</head>

<body>
    <div id="ui">
        <h1>Drymaxxing HUD</h1>

        <div class="stat-group">
            <span class="stat-label">System Status</span>
            <span class="stat-value" id="status" style="color: #ffaa00; font-size: 12px;">Initializing...</span>
        </div>

        <div class="stat-group">
            <span class="stat-label">Wetness</span>
            <span class="stat-value" id="wet-area">0.00</span> <span style="font-size:0.8em; color:#666">unitsÂ²</span>
        </div>

        <div class="stat-group">
            <span class="stat-label">Position</span>
            <span class="stat-value" id="pos-val" style="font-size: 12px;">0.0, 0.0, 0.0</span>
        </div>

        <div class="stat-group">
            <span class="stat-label">Orientation</span>
            <span class="stat-value" id="euler-val" style="font-size: 12px;">0.0, 0.0, 0.0</span>
        </div>

        <div class="stat-group">
            <span class="stat-label">Curvature (Avg)</span>
            <span class="stat-value" id="k-val">0.00</span>
        </div>

        <div class="stat-group">
            <span class="stat-label">Wetness</span>
            <canvas id="wet-heatmap" width="200" height="100" style="width: 100%; height: auto; border:1px solid #333; background:#111"></canvas>
        </div>

        <div class="stat-group">
            <span class="stat-label">Curvature</span>
            <canvas id="curv-heatmap" width="200" height="20" style="width: 100%; height: auto; border:1px solid #333; background:#111"></canvas>
        </div>

        <div class="controls-hint">
            <b>CONTROLS</b><br>
            W/S - Move<br>
            A/D - Strafe<br>
            Mouse - Look<br>
            Shift - Boost
        </div>

        <!-- Off-screen indicator if needed -->
        <div id="target-arrow" style="
            position: absolute; 
            width: 0; 
            height: 0; 
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid #ffaa00;
            display: none;
            transform-origin: center center;
            z-index: 5;
        "></div>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        // import { OrbitControls } from 'three/addons/controls/OrbitControls.js'; // REMOVED

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.up.set(0, 0, 1); // Z-UP Coordinate System

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.setClearColor(0x000000, 0);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lights
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        hemiLight.position.set(0, 0, 50); // Light from above (Z)
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(10, 10, 30); // Sun high up
        dirLight.castShadow = true;
        scene.add(dirLight);

        // Ground / Grid Reference (Floor at Z = -10)
        // Ground / Floor (at Z = -10)
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.8,
            metalness: 0.2
        });
        const floorMesh = new THREE.Mesh(floorGeo, floorMat);
        floorMesh.position.set(0, 0, -10);
        floorMesh.receiveShadow = true;
        scene.add(floorMesh);

        // Paper Mesh
        const paperGeo = new THREE.PlaneGeometry(10, 10, 49, 49);
        paperGeo.attributes.position.usage = THREE.DynamicDrawUsage;

        // Wetness Texture (Canvas)
        const wetCanvas = document.createElement('canvas');
        wetCanvas.width = 512;
        wetCanvas.height = 512;
        const wetCtx = wetCanvas.getContext('2d');
        wetCtx.fillStyle = '#ffffff';
        wetCtx.fillRect(0, 0, 512, 512);

        const wetTexture = new THREE.CanvasTexture(wetCanvas);

        const paperMat = new THREE.MeshStandardMaterial({
            map: wetTexture,
            color: 0xccffff,
            side: THREE.DoubleSide,
            roughness: 0.6,
            metalness: 0.1
        });

        const paperMesh = new THREE.Mesh(paperGeo, paperMat);
        paperMesh.castShadow = true;
        paperMesh.receiveShadow = true;
        scene.add(paperMesh);

        // Rain Visualization (Falling along -RainDir)
        let rainDir = new THREE.Vector3(0, 0, -1); // Default
        const rainCount = 5000;
        const rainGeo = new THREE.BufferGeometry();
        const rainPos = new Float32Array(rainCount * 3);
        const rainVel = new Float32Array(rainCount);
        for (let i = 0; i < rainCount; i++) {
            rainPos[i * 3] = (Math.random() - 0.5) * 60;
            rainPos[i * 3 + 1] = (Math.random() - 0.5) * 60;
            rainPos[i * 3 + 2] = Math.random() * 40; // Start high Z
            rainVel[i] = 0.5 + Math.random() * 0.5;
        }
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
        const rainMat = new THREE.PointsMaterial({
            color: 0x4488ff, // Blue rain
            size: 0.2, // Slightly larger drops
            transparent: true,
            opacity: 0.3, // subtler
            blending: THREE.AdditiveBlending
        });
        const rainSystem = new THREE.Points(rainGeo, rainMat);
        scene.add(rainSystem);

        // SPLASH TEXTURE GENERATION
        function createSplashTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');

            // Draw a ring/splash
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(100, 150, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(50, 100, 255, 0.8)');
            gradient.addColorStop(0.4, 'rgba(0, 50, 200, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        // Hit System (Splashes)
        const MAX_HITS = 1000;
        const hitGeo = new THREE.BufferGeometry();
        const hitPos = new Float32Array(MAX_HITS * 3);
        hitGeo.setAttribute('position', new THREE.BufferAttribute(hitPos, 3));

        const hitMat = new THREE.PointsMaterial({
            color: 0x88ccff, // Splash base color
            size: 0.8, // Larger for splash
            map: createSplashTexture(),
            transparent: true,
            opacity: 0.9,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });
        const hitSystem = new THREE.Points(hitGeo, hitMat);
        scene.add(hitSystem);

        // WebSocket
        // WebSocket
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const ws = new WebSocket(`${protocol}//${window.location.host}/ws`);
        const statusEl = document.getElementById('status');

        ws.onopen = () => {
            statusEl.textContent = "CONNECTED";
            statusEl.style.color = "#00ff88";
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            // Update Stats
            if (data.wet_area !== undefined)
                document.getElementById('wet-area').textContent = data.wet_area.toFixed(2);
            if (data.pos)
                document.getElementById('pos-val').textContent = data.pos.map(v => v.toFixed(1)).join(", ");
            if (data.euler)
                document.getElementById('euler-val').textContent = data.euler.map(v => v.toFixed(2)).join(", ");
            if (data.curvatures) {
                const avgK = data.curvatures.reduce((a, b) => a + b, 0) / data.curvatures.length;
                document.getElementById('k-val').textContent = avgK.toFixed(4);
                drawCurvatureHeatmap(data.curvatures);
            }
            if (data.rain_dir) {
                // Update global rain dir
                rainDir.set(data.rain_dir[0], data.rain_dir[1], data.rain_dir[2]).normalize();
            }

            // Update Paper Geometry
            if (data.vertices && data.vertices.length > 0) {
                updatePaper(data.vertices);
            }

            // Handle Wet Texture (UVs) with Fading
            // 1. Always fade out (drying)
            wetCtx.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Faster Drying speed
            wetCtx.fillRect(0, 0, 512, 512);

            // 2. Draw new rain hits
            if (data.rain_uv && data.rain_uv.length > 0) {
                // Use a stronger blue for new hits
                wetCtx.fillStyle = 'rgba(0, 0, 255, 0.5)';
                for (let uv of data.rain_uv) {
                    const x = uv[0] * 512;
                    const y = uv[1] * 512;
                    wetCtx.beginPath();
                    wetCtx.arc(x, y, 8, 0, Math.PI * 2); // Slightly larger
                    wetCtx.fill();
                }
            }
            // Always update texture
            wetTexture.needsUpdate = true;

            // Update HUD Heatmap
            const hudWetCtx = document.getElementById('wet-heatmap').getContext('2d');
            hudWetCtx.drawImage(wetCanvas, 0, 0, 200, 100);

            // Handle Rain Hits (3D)
            if (data.rain_hits && data.rain_hits.length > 0) {
                const hits = data.rain_hits;
                const count = Math.min(hits.length, MAX_HITS);
                const positions = hitSystem.geometry.attributes.position.array;

                for (let i = 0; i < count; i++) {
                    positions[i * 3] = hits[i][0];
                    positions[i * 3 + 1] = hits[i][1];
                    positions[i * 3 + 2] = hits[i][2];
                }

                // Hide unused
                for (let i = count * 3; i < MAX_HITS * 3; i++) {
                    positions[i] = 0; // Or NaN/Infinity to hide, or just setDrawRange
                }

                hitSystem.geometry.setDrawRange(0, count);
                hitSystem.geometry.attributes.position.needsUpdate = true;
            } else {
                hitSystem.geometry.setDrawRange(0, 0);
            }
        };

        let uvInitialized = false;

        function updatePaper(flatVerts) {
            // Check sizes
            const positions = paperGeo.attributes.position.array;
            const uvs = paperGeo.attributes.uv.array;

            // Expected size: 9x59 segments -> 10x60 points
            // flatVerts is typically [60][10][3]

            let idx = 0;
            // Iterate properly
            // ThreeJS PlaneGeometry order:
            // It builds row by row. 
            // We need to match our data.
            // Data: flatVerts[i][j] where i is profile index, j is width index.

            // Safety check
            if (!flatVerts || !flatVerts[0]) return;

            const n_profile = flatVerts.length;
            const n_rulings = flatVerts[0].length;

            for (let i = 0; i < n_profile; i++) {
                for (let j = 0; j < n_rulings; j++) {
                    if (idx < positions.length) {
                        const pt = flatVerts[i][j];
                        positions[idx++] = pt[0];
                        positions[idx++] = pt[1];
                        positions[idx++] = pt[2];
                    }
                }
            }
            paperGeo.attributes.position.needsUpdate = true;
            paperGeo.computeVertexNormals();

            // Initialize UVs once to match texture layout
            if (!uvInitialized) {
                idx = 0;
                for (let i = 0; i < n_profile; i++) {
                    for (let j = 0; j < n_rulings; j++) {
                        // Profile -> U (X), Width -> V (Y)
                        // Flip V to fix 180 degree mismatch
                        const u = i / (n_profile - 1);
                        const v = 1.0 - (j / (n_rulings - 1));

                        uvs[2 * idx] = u;
                        uvs[2 * idx + 1] = v;
                        idx++;
                    }
                }
                paperGeo.attributes.uv.needsUpdate = true;
                uvInitialized = true;
            }
        }

        function drawCurvatureHeatmap(k_vals) {
            const ctx = document.getElementById('curv-heatmap').getContext('2d');
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            const barW = w / k_vals.length;
            ctx.clearRect(0, 0, w, h);
            for (let i = 0; i < k_vals.length; i++) {
                const k = k_vals[i];
                // Max curvature is clipped at 2.0 in env.py.
                // We want a nice gradient. 
                // Let's say full red at 2.0, green at 0.
                const intensity = Math.min(Math.abs(k) / 2.0, 1.0);
                
                const r = Math.floor(intensity * 255);
                const g = Math.floor((1.0 - intensity) * 255);
                ctx.fillStyle = `rgb(${r}, ${g}, 0)`;
                ctx.fillRect(i * barW, 0, barW + 1, h); // +1 to avoid gaps
            }
        }

        // Starfield Skybox
        const starGeo = new THREE.BufferGeometry();
        const starCount = 1000;
        const starPos = new Float32Array(starCount * 3);
        const starRad = 200; // Radius where stars live
        for (let i = 0; i < starCount; i++) {
            // Random spherical calc
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = starRad * (0.8 + Math.random() * 0.4); // slightly varied depth
            starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            starPos[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            starPos[i * 3 + 2] = r * Math.cos(phi);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.7, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // Camera Controls & Animation
        const keys = {};
        window.addEventListener('keydown', (e) => keys[e.code] = true);
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        // Camera: FPS / Fly Controls
        // Z-UP: Looks -> Yaw around Z, Pitch around Local X.

        let yaw = 0;
        let pitch = 0;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Start position
        camera.position.set(0, -20, 10);
        camera.lookAt(0, 0, 0);

        // Recover euler
        const initialEuler = new THREE.Euler().setFromQuaternion(camera.quaternion, 'ZYX');
        yaw = initialEuler.z;
        pitch = initialEuler.x;

        // Mouse Events
        window.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;

            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;

            const sensitivity = 0.002;
            yaw -= dx * sensitivity;
            pitch -= dy * sensitivity;

            // Clamp pitch
            const limit = Math.PI / 2 - 0.01;
            pitch = Math.max(-limit, Math.min(limit, pitch));

            updateCameraRotation();
        });

        function updateCameraRotation() {
            // ZYX order: Z=Yaw, Y=Roll(0), X=Pitch
            camera.rotation.set(pitch, 0, yaw, 'ZYX');
        }

        // Physics / Movement
        const velocity = new THREE.Vector3();
        const friction = 0.9;
        const acceleration = 0.05;
        const boostMultiplier = 3.0;

        function updateMovement() {
            // Forward is -Y in camera local? NO.
            // standard camera looks down -Z local.
            // We want to move in WORLD XY plane. 
            // Get view dir projected to XY.

            const viewDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

            // Forward on XY plane
            const forward = new THREE.Vector3(viewDir.x, viewDir.y, 0).normalize();
            // Right is Cross(Forward, WorldUp) = Cross(Forward, Z)
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 0, 1)).normalize();
            const up = new THREE.Vector3(0, 0, 1);

            // Input Force
            const inputAccel = keys['ShiftLeft'] ? acceleration * boostMultiplier : acceleration;
            const moveVec = new THREE.Vector3();

            if (keys['KeyW']) moveVec.add(forward);
            if (keys['KeyS']) moveVec.sub(forward);
            if (keys['KeyA']) moveVec.sub(right);
            if (keys['KeyD']) moveVec.add(right);
            if (keys['KeyQ']) moveVec.add(up);
            if (keys['KeyE']) moveVec.sub(up);

            if (moveVec.lengthSq() > 0) {
                moveVec.normalize().multiplyScalar(inputAccel);
                velocity.add(moveVec);
            }

            // Apply Velocity
            camera.position.add(velocity);
            velocity.multiplyScalar(friction);
            if (velocity.lengthSq() < 0.000001) velocity.set(0, 0, 0);

            // Update Skybox
            stars.position.copy(camera.position);
        }

        function animate() {
            requestAnimationFrame(animate);
            updateMovement();

            // Animate global rain (Falls along rainDir)
            // We want rain to fall 'down' relative to the vector.
            // Actually rainDir is the direction it falls TOWARDS.
            // So we add rainDir * speed * dt.

            const rPos = rainSystem.geometry.attributes.position.array;

            // Bounds
            const bounds = 40;

            for (let i = 0; i < rainCount; i++) {
                const speed = rainVel[i];

                rPos[i * 3] += rainDir.x * speed;
                rPos[i * 3 + 1] += rainDir.y * speed;
                rPos[i * 3 + 2] += rainDir.z * speed;

                // Reset if out of bounds (simple box wrap)
                // If it goes too low (below -10) or too far sideways
                // We prefer to respawn it 'above' relative to rainDir.
                // Simplified: just check Z and maybe distance.

                if (rPos[i * 3 + 2] < -10 || Math.abs(rPos[i * 3]) > 80 || Math.abs(rPos[i * 3 + 1]) > 80) {
                    // Respawn upwind
                    const spawnZ = 30 + Math.random() * 20;
                    // Wider destination area
                    const destX = (Math.random() - 0.5) * 120;
                    const destY = (Math.random() - 0.5) * 120;

                    const rz = (Math.abs(rainDir.z) < 0.1) ? -0.1 : rainDir.z;
                    const t = -spawnZ / rz;

                    rPos[i * 3] = destX - rainDir.x * t;
                    rPos[i * 3 + 1] = destY - rainDir.y * t;
                    rPos[i * 3 + 2] = spawnZ;
                }
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>